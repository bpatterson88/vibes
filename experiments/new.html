<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Example - Canvas, Context, and Shaders</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: default;
        }
        
        /* Reticule (crosshair) in center of screen */
        #reticule {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 100;
        }
        
        #reticule::before,
        #reticule::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        
        /* Horizontal line */
        #reticule::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }
        
        /* Vertical line */
        #reticule::after {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }
        
        /* Center dot */
        #reticule-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 0, 0, 0.9);
            border-radius: 50%;
        }
        
        /* Distance display in bottom right */
        #distance-display {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            border: 2px solid rgba(0, 255, 0, 0.5);
            border-radius: 5px;
            pointer-events: none;
            z-index: 100;
            min-width: 200px;
        }
        
        #distance-display .label {
            color: #888;
            font-size: 12px;
        }
        
        #distance-display .value {
            color: #00ff00;
            font-weight: bold;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    
    <!-- Reticule (crosshair) in center -->
    <div id="reticule">
        <div id="reticule-dot"></div>
    </div>
    
    <!-- Distance display in bottom right -->
    <div id="distance-display">
        <div class="label">TARGET DISTANCE</div>
        <div class="value">--</div>
    </div>

    <script>
        // ============================================
        // 2. SHADER SOURCE CODE (GLSL)
        // ============================================
        
        // VERTEX SHADER - Runs once per vertex
        // Transforms 3D vertex positions with perspective projection
        const vertexShaderSource = `
            attribute vec3 aPosition;  // Input: vertex position (x, y, z)
            attribute vec4 aColor;     // Input: vertex color (r, g, b, a)
            
            varying vec4 vColor;       // Output: pass color to fragment shader
            varying float vDepth;      // Output: depth for color fading
            
            uniform float uRotationX;  // Rotation around X axis
            uniform float uRotationY;  // Rotation around Y axis
            uniform mat4 uProjection;  // Perspective projection matrix
            
            void main() {
                // Apply rotation around Y axis (horizontal spin)
                float cosY = cos(uRotationY);
                float sinY = sin(uRotationY);
                mat3 rotationY = mat3(
                    cosY, 0.0, sinY,
                    0.0, 1.0, 0.0,
                    -sinY, 0.0, cosY
                );
                
                // Apply rotation around X axis (vertical tilt)
                float cosX = cos(uRotationX);
                float sinX = sin(uRotationX);
                mat3 rotationX = mat3(
                    1.0, 0.0, 0.0,
                    0.0, cosX, -sinX,
                    0.0, sinX, cosX
                );
                
                // Combine rotations and apply to position
                vec3 rotated = rotationX * rotationY * aPosition;
                
                // Apply perspective projection
                gl_Position = uProjection * vec4(rotated, 1.0);
                
                // Set point size based on depth (closer = bigger)
                gl_PointSize = 3.0 + (2.0 / (gl_Position.z + 2.0));
                
                // Pass color and depth to fragment shader
                vColor = aColor;
                vDepth = rotated.z;
            }
        `;
        
        // FRAGMENT SHADER - Runs once per pixel
        // Determines the final color of each pixel with depth-based fading
        const fragmentShaderSource = `
            precision mediump float;
            
            varying vec4 vColor;   // Input: color from vertex shader (rgba)
            varying float vDepth;  // Input: depth from vertex shader
            
            void main() {
                // For points: make them circular and apply depth fading
                // gl_PointCoord is (0,0) to (1,1) for points, but undefined for triangles
                vec2 pointCoord = gl_PointCoord;
                if (pointCoord.x > 0.0 && pointCoord.y > 0.0) {
                    // Likely rendering points
                    vec2 coord = pointCoord - vec2(0.5);
                    if (length(coord) > 0.5) {
                        discard;  // Make points circular
                    }
                    // Apply depth-based alpha fading
                    float depthAlpha = 1.0 - smoothstep(0.0, 3.0, abs(vDepth));
                    gl_FragColor = vec4(vColor.rgb, vColor.a * depthAlpha);
                } else {
                    // Rendering triangles - use vertex color directly
                    gl_FragColor = vColor;
                }
            }
        `;
        
        // ============================================
        // 3. GET CANVAS AND WEBGL CONTEXT
        // ============================================
        
        const canvas = document.getElementById('glCanvas');
        
        // Set initial canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported in your browser!');
            throw new Error('WebGL not available');
        }
        
        console.log('âœ“ WebGL context created successfully');
        
        // ============================================
        // 4. COMPILE SHADERS
        // ============================================
        
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            // Check for compilation errors
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        console.log('âœ“ Shaders compiled successfully');
        
        // ============================================
        // 5. CREATE AND LINK SHADER PROGRAM
        // ============================================
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
            throw new Error('Failed to link program');
        }
        
        gl.useProgram(program);
        console.log('âœ“ Shader program linked and activated');
        
        // ============================================
        // 6. SET UP VERTEX DATA - 3D POINT FIELD
        // ============================================
        
        // Create randomly scattered stars
        const starCount = 3000;  // Number of stars
        const spreadRadius = 3.0;  // How far stars can be from center
        const trailLength = 15;  // Number of historical positions to keep (half as long)
        
        // Store original positions and colors
        const stars = [];
        
        // Array to store shooting stars
        const shootingStars = [];
        
        for (let i = 0; i < starCount; i++) {
            // Random position within a sphere (using spherical coordinates for even distribution)
            const theta = Math.random() * Math.PI * 2;  // Azimuthal angle
            const phi = Math.acos(2 * Math.random() - 1);  // Polar angle
            const radius = Math.cbrt(Math.random()) * spreadRadius;  // Cube root for even volume distribution
            
            const px = radius * Math.sin(phi) * Math.cos(theta);
            const py = radius * Math.sin(phi) * Math.sin(theta);
            const pz = radius * Math.cos(phi);
            
            // Random vibrant colors
            const r = Math.random() * 0.5 + 0.5;  // 0.5 to 1.0 for brighter colors
            const g = Math.random() * 0.5 + 0.5;
            const b = Math.random() * 0.5 + 0.5;
            
            stars.push({
                original: [px, py, pz],
                color: [r, g, b],
                history: [],  // Will store [x, y, z] for each frame
                twinkleOffset: Math.random() * 100,  // Random offset for twinkle timing
                twinkleSpeed: 0.5 + Math.random() * 1.5  // Random speed multiplier
            });
        }
        
        // Create dynamic buffer for current stars
        const starBuffer = gl.createBuffer();
        
        // Create dynamic buffer for trail lines
        const trailBuffer = gl.createBuffer();
        
        console.log(`âœ“ Created ${starCount} stars with trail support`);
        
        // ============================================
        // 6.3. CREATE PYRAMID GEOMETRY FOR ENEMIES
        // ============================================
        
        function createPyramid(size = 1.0) {
            // Pyramid with square base
            const halfSize = size / 2;
            
            // 5 vertices: 4 for base, 1 for apex
            const vertices = [
                // Base vertices (square on XY plane)
                [-halfSize, -halfSize, 0],  // 0: bottom-left
                [halfSize, -halfSize, 0],   // 1: bottom-right
                [halfSize, halfSize, 0],    // 2: top-right
                [-halfSize, halfSize, 0],   // 3: top-left
                // Apex
                [0, 0, size]                // 4: apex (pointing in +Z direction, toward viewer)
            ];
            
            // Triangular faces (5 faces total: 4 sides + 1 base)
            const faces = [
                // 4 side faces (triangles pointing toward apex)
                [0, 1, 4],  // Front face
                [1, 2, 4],  // Right face
                [2, 3, 4],  // Back face
                [3, 0, 4],  // Left face
                // Base face (2 triangles forming square)
                [0, 2, 1],
                [0, 3, 2]
            ];
            
            return { vertices, faces };
        }
        
        const pyramidGeometry = createPyramid(0.3);  // Base size for pyramids
        console.log('âœ“ Pyramid geometry created');
        
        // Enemy system
        const enemies = [];
        const enemyBuffer = gl.createBuffer();
        
        // Function to spawn an enemy
        function spawnEnemy() {
            // Random position around the periphery, far from camera
            const angle = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);  // Random spherical angle
            const spawnDistance = 8.0 + Math.random() * 6.0;  // Spawn 8-14 units from origin (varied distance)
            
            const spawnX = spawnDistance * Math.sin(phi) * Math.cos(angle);
            const spawnY = spawnDistance * Math.sin(phi) * Math.sin(angle);
            const spawnZ = spawnDistance * Math.cos(phi);
            
            // Calculate direction vector from spawn position to origin (0,0,0)
            const dirX = 0 - spawnX;
            const dirY = 0 - spawnY;
            const dirZ = 0 - spawnZ;
            
            // Normalize the direction vector
            const distance = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
            
            // Calculate speed to reach origin in 20-30 seconds
            // At 60fps: 20-30 seconds = 1200-1800 frames
            // Speed = distance / frames
            const travelTime = 1200 + Math.random() * 600;  // 1200-1800 frames (20-30 seconds)
            const speed = distance / travelTime;
            
            // Calculate rotation to point apex toward origin
            // The pyramid's apex points in +Z direction by default
            // We need to rotate it to point toward (0,0,0)
            const horizontalAngle = Math.atan2(dirX, dirZ);  // Rotation around Y axis
            const verticalAngle = Math.atan2(dirY, Math.sqrt(dirX * dirX + dirZ * dirZ));  // Rotation around X axis
            
            const enemy = {
                position: [spawnX, spawnY, spawnZ],
                velocity: [
                    (dirX / distance) * speed,
                    (dirY / distance) * speed,
                    (dirZ / distance) * speed
                ],
                rotationY: horizontalAngle,  // Fixed rotation pointing toward origin
                rotationX: -verticalAngle,   // Fixed rotation pointing toward origin
                size: 0.6 + Math.random() * 0.4,  // 0.6-1.0 (much larger than stars)
                color: [
                    0.8 + Math.random() * 0.2,  // Red: 0.8-1.0
                    0.1 + Math.random() * 0.1,  // Green: 0.1-0.2 (minimal)
                    0.1 + Math.random() * 0.1   // Blue: 0.1-0.2 (minimal)
                ]
            };
            
            enemies.push(enemy);
            console.log('ðŸ‘¾ Enemy spawned!');
        }
        
        // Spawn initial enemies
        for (let i = 0; i < 5; i++) {
            spawnEnemy();
        }
        
        let lastEnemySpawnTime = 0;
        
        console.log('âœ“ Enemy system initialized');
        
        // ============================================
        // 6.5. CREATE ICOSPHERE FOR DIRECTION INDICATOR
        // ============================================
        
        function createIcosphere(subdivisions = 2) {
            // Base icosahedron vertices (12 vertices on unit sphere)
            const t = (1.0 + Math.sqrt(5.0)) / 2.0;
            const vertices = [
                [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
                [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
                [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
            ].map(v => {
                const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
                return [v[0] / len, v[1] / len, v[2] / len];
            });
            
            // Base icosahedron faces (20 triangular faces)
            let faces = [
                [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
            ];
            
            // Subdivide faces
            for (let i = 0; i < subdivisions; i++) {
                const newFaces = [];
                const midpointCache = {};
                
                const getMidpoint = (i1, i2) => {
                    const key = i1 < i2 ? `${i1},${i2}` : `${i2},${i1}`;
                    if (midpointCache[key] !== undefined) {
                        return midpointCache[key];
                    }
                    
                    const v1 = vertices[i1];
                    const v2 = vertices[i2];
                    const mid = [
                        (v1[0] + v2[0]) / 2,
                        (v1[1] + v2[1]) / 2,
                        (v1[2] + v2[2]) / 2
                    ];
                    
                    // Normalize to sphere
                    const len = Math.sqrt(mid[0] * mid[0] + mid[1] * mid[1] + mid[2] * mid[2]);
                    const normalized = [mid[0] / len, mid[1] / len, mid[2] / len];
                    
                    const index = vertices.length;
                    vertices.push(normalized);
                    midpointCache[key] = index;
                    return index;
                };
                
                faces.forEach(face => {
                    const [v0, v1, v2] = face;
                    const m0 = getMidpoint(v0, v1);
                    const m1 = getMidpoint(v1, v2);
                    const m2 = getMidpoint(v2, v0);
                    
                    newFaces.push([v0, m0, m2]);
                    newFaces.push([v1, m1, m0]);
                    newFaces.push([v2, m2, m1]);
                    newFaces.push([m0, m1, m2]);
                });
                
                faces = newFaces;
            }
            
            // Calculate face normals (center of each triangle)
            const faceNormals = faces.map(face => {
                const v0 = vertices[face[0]];
                const v1 = vertices[face[1]];
                const v2 = vertices[face[2]];
                
                // Face center
                const center = [
                    (v0[0] + v1[0] + v2[0]) / 3,
                    (v0[1] + v1[1] + v2[1]) / 3,
                    (v0[2] + v1[2] + v2[2]) / 3
                ];
                
                // Normalize (should already be ~1 on sphere)
                const len = Math.sqrt(center[0] * center[0] + center[1] * center[1] + center[2] * center[2]);
                return [center[0] / len, center[1] / len, center[2] / len];
            });
            
            return { vertices, faces, faceNormals };
        }
        
        // Generate icosphere with 2 subdivisions (~80 faces) for direction indicator
        const icosphere = createIcosphere(2);
        console.log(`âœ“ Created icosphere: ${icosphere.vertices.length} vertices, ${icosphere.faces.length} faces`);
        
        // Generate higher-resolution icosphere for planets (smoother surface)
        const planetGeometry = createIcosphere(3);
        console.log(`âœ“ Created planet geometry: ${planetGeometry.vertices.length} vertices, ${planetGeometry.faces.length} faces`);
        
        // Create sphere vertex buffer (will be updated per-frame with colors)
        const sphereBuffer = gl.createBuffer();
        
        // Create sphere index buffer (static)
        const sphereIndexBuffer = gl.createBuffer();
        const sphereIndices = new Uint16Array(icosphere.faces.flat());
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphereIndices, gl.STATIC_DRAW);
        
        console.log('âœ“ Sphere buffers created');
        
        // ============================================
        // 6.6. CREATE PLANET SYSTEM
        // ============================================
        
        const planetCount = 15;
        const planets = [];
        
        // Earth-like color palettes for variety
        const planetColorPalettes = [
            // Ocean blue planets
            { base: [0.2, 0.4, 0.8], highlight: [0.4, 0.6, 0.95] },
            { base: [0.15, 0.35, 0.75], highlight: [0.35, 0.55, 0.9] },
            // Green/blue earth-like
            { base: [0.3, 0.6, 0.4], highlight: [0.5, 0.8, 0.6] },
            { base: [0.25, 0.55, 0.45], highlight: [0.45, 0.75, 0.65] },
            // Brown/tan terrestrial
            { base: [0.6, 0.5, 0.3], highlight: [0.8, 0.7, 0.5] },
            { base: [0.55, 0.45, 0.35], highlight: [0.75, 0.65, 0.55] },
            // Cyan water worlds
            { base: [0.3, 0.7, 0.7], highlight: [0.5, 0.9, 0.9] },
            // Dark blue deep ocean
            { base: [0.15, 0.25, 0.5], highlight: [0.3, 0.45, 0.7] }
        ];
        
        for (let i = 0; i < planetCount; i++) {
            // Random position within sphere
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const radius = Math.cbrt(Math.random()) * spreadRadius;
            
            const px = radius * Math.sin(phi) * Math.cos(theta);
            const py = radius * Math.sin(phi) * Math.sin(theta);
            const pz = radius * Math.cos(phi);
            
            // Random size between 0.05-0.1 units (diameter)
            const size = 0.05 + Math.random() * 0.05;
            
            // Pick random color palette
            const palette = planetColorPalettes[Math.floor(Math.random() * planetColorPalettes.length)];
            
            planets.push({
                original: [px, py, pz],
                size: size,
                colorBase: palette.base,
                colorHighlight: palette.highlight,
                rotationOffset: Math.random() * Math.PI * 2  // Random starting rotation
            });
        }
        
        const planetBuffer = gl.createBuffer();
        
        console.log(`âœ“ Created ${planetCount} planets with shading`);
        
        // ============================================
        // 7. CONFIGURE VERTEX ATTRIBUTES
        // ============================================
        
        // Get attribute locations
        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const aColor = gl.getAttribLocation(program, 'aColor');
        
        // Define how to read position data (3 floats for x, y, z)
        gl.vertexAttribPointer(
            aPosition,           // attribute location
            3,                   // number of components (x, y, z)
            gl.FLOAT,           // data type
            false,              // normalize?
            6 * Float32Array.BYTES_PER_ELEMENT,  // stride (6 floats per vertex)
            0                   // offset (start at beginning)
        );
        gl.enableVertexAttribArray(aPosition);
        
        // Define how to read color data (3 floats, starting after position)
        gl.vertexAttribPointer(
            aColor,             // attribute location
            3,                  // number of components (r, g, b)
            gl.FLOAT,          // data type
            false,             // normalize?
            6 * Float32Array.BYTES_PER_ELEMENT,  // stride (6 floats per vertex)
            3 * Float32Array.BYTES_PER_ELEMENT   // offset (skip 3 floats for position)
        );
        gl.enableVertexAttribArray(aColor);
        
        // Get uniform locations
        const uRotationX = gl.getUniformLocation(program, 'uRotationX');
        const uRotationY = gl.getUniformLocation(program, 'uRotationY');
        const uProjection = gl.getUniformLocation(program, 'uProjection');
        
        console.log('âœ“ Vertex attributes configured');
        
        // Enable depth testing for proper 3D occlusion
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        
        // ============================================
        // 8. RENDERING SETUP
        // ============================================
        
        // Set clear color (background)
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        
        // Enable blending for transparency (depth fading)
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        
        // Create perspective projection matrix
        function createPerspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) / (near - far), -1,
                0, 0, (2 * far * near) / (near - far), 0
            ]);
        }
        
        // Set up projection matrix
        const fov = Math.PI / 4;  // 45 degrees
        const aspect = canvas.width / canvas.height;
        const near = 0.1;
        const far = 100.0;
        const projectionMatrix = createPerspectiveMatrix(fov, aspect, near, far);
        
        // Upload projection matrix to shader (only once as it doesn't change)
        gl.uniformMatrix4fv(uProjection, false, projectionMatrix);
        
        console.log('âœ“ Rendering setup complete');
        
        // ============================================
        // 9. POINTER LOCK INTERACTION (UNLIMITED ROTATION)
        // ============================================
        
        let rotationY = 0;
        let rotationX = 0.3;
        let targetRotationY = 0;
        let targetRotationX = 0.3;
        
        // Sensitivity for rotation (adjust these values to change rotation speed)
        const sensitivityX = 0.003;  // Horizontal rotation sensitivity
        const sensitivityY = 0.003;  // Vertical rotation sensitivity
        
        // Request pointer lock on canvas click
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });
        
        // Handle pointer lock changes
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                console.log('âœ“ Pointer locked - unlimited rotation enabled');
            } else {
                console.log('âœ“ Pointer unlocked');
            }
        });
        
        // Handle pointer lock errors
        document.addEventListener('pointerlockerror', () => {
            console.error('âœ— Pointer lock error');
        });
        
        // Mouse movement with pointer lock - uses movementX/Y for unlimited rotation
        document.addEventListener('mousemove', (e) => {
            // Only process movement when pointer is locked
            if (document.pointerLockElement === canvas) {
                // Use movementX/Y which works even at viewport edges
                const deltaX = e.movementX;
                const deltaY = e.movementY;
                
                // Update target rotations based on mouse movement
                targetRotationY += deltaX * sensitivityX;
                targetRotationX += deltaY * sensitivityY;
                
                // No clamping - allow full 360Â° rotation on all axes!
            }
        });
        
        console.log('âœ“ Pointer lock controls enabled (click to activate, ESC to release)');
        
        // ============================================
        // 9.5. DISTANCE TRACKING SYSTEM
        // ============================================
        
        // Get reference to distance display element
        const distanceDisplay = document.querySelector('#distance-display .value');
        
        // Helper function to find the closest object to the center reticule
        function findClosestObjectToCenter() {
            let closestObject = null;
            let closestDistanceToRay = Infinity;
            let closestActualDistance = 0;
            
            // Calculate viewing direction (forward is -Z in view space)
            const viewDir = [0, 0, -1];  // Looking down -Z axis in view space
            
            // Check all stars
            stars.forEach((star, index) => {
                // Apply auto-rotation and camera rotation to get view space position
                const autoRotated = applyAutoRotation(star.original, time);
                const viewSpacePos = rotatePoint(autoRotated, rotationX, rotationY);
                
                // Only consider objects in front of camera (negative Z in view space)
                if (viewSpacePos[2] < 0) {
                    // Calculate distance from center ray
                    // The ray goes through origin in direction [0, 0, -1]
                    // Distance from point to ray is just sqrt(xÂ² + yÂ²)
                    const distanceToRay = Math.sqrt(viewSpacePos[0] * viewSpacePos[0] + viewSpacePos[1] * viewSpacePos[1]);
                    
                    // Weight by depth to prefer closer objects
                    const weightedDistance = distanceToRay / Math.abs(viewSpacePos[2]);
                    
                    if (weightedDistance < closestDistanceToRay && weightedDistance < 0.5) {  // 0.5 is max angular distance
                        closestDistanceToRay = weightedDistance;
                        // Calculate actual distance from origin to object in world space
                        closestActualDistance = Math.sqrt(
                            autoRotated[0] * autoRotated[0] +
                            autoRotated[1] * autoRotated[1] +
                            autoRotated[2] * autoRotated[2]
                        );
                        closestObject = { type: 'star', index };
                    }
                }
            });
            
            // Check all planets
            planets.forEach((planet, index) => {
                const autoRotated = applyAutoRotation(planet.original, time);
                const viewSpacePos = rotatePoint(autoRotated, rotationX, rotationY);
                
                if (viewSpacePos[2] < 0) {
                    const distanceToRay = Math.sqrt(viewSpacePos[0] * viewSpacePos[0] + viewSpacePos[1] * viewSpacePos[1]);
                    const weightedDistance = distanceToRay / Math.abs(viewSpacePos[2]);
                    
                    // Planets have size, so include a radius check
                    const effectiveDistance = Math.max(0, weightedDistance - planet.size);
                    
                    if (effectiveDistance < closestDistanceToRay && effectiveDistance < 0.5) {
                        closestDistanceToRay = effectiveDistance;
                        closestActualDistance = Math.sqrt(
                            autoRotated[0] * autoRotated[0] +
                            autoRotated[1] * autoRotated[1] +
                            autoRotated[2] * autoRotated[2]
                        );
                        closestObject = { type: 'planet', index };
                    }
                }
            });
            
            // Check all enemies
            enemies.forEach((enemy, index) => {
                const viewSpacePos = rotatePoint(enemy.position, rotationX, rotationY);
                
                if (viewSpacePos[2] < 0) {
                    const distanceToRay = Math.sqrt(viewSpacePos[0] * viewSpacePos[0] + viewSpacePos[1] * viewSpacePos[1]);
                    const weightedDistance = distanceToRay / Math.abs(viewSpacePos[2]);
                    
                    // Enemies have size, so include a radius check
                    const effectiveDistance = Math.max(0, weightedDistance - enemy.size);
                    
                    if (effectiveDistance < closestDistanceToRay && effectiveDistance < 0.5) {
                        closestDistanceToRay = effectiveDistance;
                        closestActualDistance = Math.sqrt(
                            enemy.position[0] * enemy.position[0] +
                            enemy.position[1] * enemy.position[1] +
                            enemy.position[2] * enemy.position[2]
                        );
                        closestObject = { type: 'enemy', index };
                    }
                }
            });
            
            if (closestObject) {
                return {
                    object: closestObject,
                    distance: closestActualDistance
                };
            }
            
            return null;
        }
        
        // ============================================
        // 10. ANIMATION LOOP WITH POSITION HISTORY TRAILS
        // ============================================
        
        // Smooth noise function for organic twinkling
        function smoothNoise(x) {
            // Multi-octave noise for natural variation
            const noise1 = Math.sin(x * 1.0) * 0.5;
            const noise2 = Math.sin(x * 2.3 + 1.5) * 0.3;
            const noise3 = Math.sin(x * 4.7 + 3.7) * 0.2;
            return (noise1 + noise2 + noise3) * 0.5 + 0.5; // Normalize to 0-1
        }
        
        let time = 0;
        let lastShootingStarTime = 0;
        
        // Function to spawn a shooting star
        function spawnShootingStar() {
            // Random starting position on the outer sphere
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = spreadRadius * 1.2;  // Start slightly outside the sphere
            
            const startX = radius * Math.sin(phi) * Math.cos(theta);
            const startY = radius * Math.sin(phi) * Math.sin(theta);
            const startZ = radius * Math.cos(phi);
            
            // Random velocity direction (generally inward with some variation)
            const velocityMag = 0.08 + Math.random() * 0.04;  // Speed: 0.08-0.12 units per frame
            const targetTheta = theta + (Math.random() - 0.5) * Math.PI * 0.5;
            const targetPhi = phi + (Math.random() - 0.5) * Math.PI * 0.5;
            
            const velocityX = -Math.sin(targetPhi) * Math.cos(targetTheta) * velocityMag;
            const velocityY = -Math.sin(targetPhi) * Math.sin(targetTheta) * velocityMag;
            const velocityZ = -Math.cos(targetPhi) * velocityMag;
            
            // Bright white/yellow color for shooting star
            const colorVariation = Math.random() * 0.2;
            const shootingStar = {
                position: [startX, startY, startZ],
                velocity: [velocityX, velocityY, velocityZ],
                color: [1.0, 1.0 - colorVariation, 0.9 - colorVariation],  // White to yellow-white
                lifetime: 0,
                maxLifetime: 60 + Math.random() * 30,  // 60-90 frames (~2-3 seconds)
                history: [],
                trailLength: 40  // Longer trail for shooting stars
            };
            
            shootingStars.push(shootingStar);
            console.log('âœ¨ Shooting star spawned!');
        }
        
        // Helper function to rotate a 3D point
        function rotatePoint(point, rotX, rotY) {
            const [x, y, z] = point;
            
            // Rotate around Y axis
            const cosY = Math.cos(rotY);
            const sinY = Math.sin(rotY);
            const x1 = x * cosY + z * sinY;
            const z1 = -x * sinY + z * cosY;
            
            // Rotate around X axis
            const cosX = Math.cos(rotX);
            const sinX = Math.sin(rotX);
            const y1 = y * cosX - z1 * sinX;
            const z2 = y * sinX + z1 * cosX;
            
            return [x1, y1, z2];
        }
        
        // Helper function to apply automatic slow rotation to stars
        function applyAutoRotation(point, time) {
            const [x, y, z] = point;
            
            // Very slow rotation speeds (one full rotation takes ~150 seconds)
            const rotSpeed = 0.01;
            const rotY = time * rotSpeed;
            const rotX = time * rotSpeed * 0.7;  // Slightly different speeds for more organic movement
            
            // Rotate around Y axis
            const cosY = Math.cos(rotY);
            const sinY = Math.sin(rotY);
            const x1 = x * cosY + z * sinY;
            const z1 = -x * sinY + z * cosY;
            
            // Rotate around X axis
            const cosX = Math.cos(rotX);
            const sinX = Math.sin(rotX);
            const y1 = y * cosX - z1 * sinX;
            const z2 = y * sinX + z1 * cosX;
            
            return [x1, y1, z2];
        }
        
        function render() {
            // Smoothly interpolate to target rotation (for smooth dragging)
            rotationY += (targetRotationY - rotationY) * 0.1;
            rotationX += (targetRotationX - rotationX) * 0.1;
            
            // Increment time for twinkle animation
            time += 0.03;
            
            // Spawn shooting stars randomly every 8-12 seconds
            const timeSinceLastStar = time - lastShootingStarTime;
            const nextStarDelay = 8 + Math.random() * 4;  // 8-12 seconds (in time units)
            if (timeSinceLastStar > nextStarDelay) {
                spawnShootingStar();
                lastShootingStarTime = time;
            }
            
            // Update shooting stars
            shootingStars.forEach(star => {
                // Update position
                star.position[0] += star.velocity[0];
                star.position[1] += star.velocity[1];
                star.position[2] += star.velocity[2];
                
                // Apply camera rotation to position for rendering
                const rotated = rotatePoint(star.position, rotationX, rotationY);
                
                // Add to history
                star.history.push(rotated);
                if (star.history.length > star.trailLength) {
                    star.history.shift();
                }
                
                star.lifetime++;
            });
            
            // Remove expired shooting stars
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                if (shootingStars[i].lifetime > shootingStars[i].maxLifetime) {
                    shootingStars.splice(i, 1);
                }
            }
            
            // ============================================
            // UPDATE ENEMIES
            // ============================================
            
            // Update enemy positions (no rotation update - enemies maintain fixed orientation)
            enemies.forEach(enemy => {
                // Move toward origin (0,0,0) using velocity vector
                enemy.position[0] += enemy.velocity[0];
                enemy.position[1] += enemy.velocity[1];
                enemy.position[2] += enemy.velocity[2];
            });
            
            // Remove enemies that have reached the origin (0,0,0)
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                // Calculate distance from origin
                const distanceFromOrigin = Math.sqrt(
                    enemy.position[0] * enemy.position[0] +
                    enemy.position[1] * enemy.position[1] +
                    enemy.position[2] * enemy.position[2]
                );
                
                // Despawn when very close to origin (within 0.3 units)
                if (distanceFromOrigin < 0.3) {
                    enemies.splice(i, 1);
                    console.log('ðŸ’¥ Enemy reached the origin and despawned!');
                }
            }
            
            // Spawn new enemies periodically
            const timeSinceLastEnemy = time - lastEnemySpawnTime;
            if (timeSinceLastEnemy > .5 && enemies.length < 50) {  // Spawn every 5 seconds, max 8
                spawnEnemy();
                lastEnemySpawnTime = time;
            }
            
            // Calculate background color based on viewing direction
            // Normalize rotation to 0-2Ï€ range
            let normalizedRotation = ((rotationY % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
            
            // Map rotation to cardinal directions with smooth color transitions
            // North (0Â°): Deep blue
            // East (90Â°): Warm yellow/gold (sunrise)
            // South (180Â°): Deep red/purple
            // West (270Â°): Orange (sunset)
            
            let r, g, b;
            
            if (normalizedRotation < Math.PI / 2) {
                // North to East (0Â° to 90Â°)
                const t = normalizedRotation / (Math.PI / 2);
                r = 0.02 + t * 0.08;  // 0.02 -> 0.10
                g = 0.02 + t * 0.06;  // 0.02 -> 0.08
                b = 0.08 - t * 0.04;  // 0.08 -> 0.04
            } else if (normalizedRotation < Math.PI) {
                // East to South (90Â° to 180Â°)
                const t = (normalizedRotation - Math.PI / 2) / (Math.PI / 2);
                r = 0.10 - t * 0.02;  // 0.10 -> 0.08
                g = 0.08 - t * 0.06;  // 0.08 -> 0.02
                b = 0.04 + t * 0.02;  // 0.04 -> 0.06
            } else if (normalizedRotation < Math.PI * 1.5) {
                // South to West (180Â° to 270Â°)
                const t = (normalizedRotation - Math.PI) / (Math.PI / 2);
                r = 0.08 + t * 0.02;  // 0.08 -> 0.10
                g = 0.02 + t * 0.04;  // 0.02 -> 0.06
                b = 0.06 - t * 0.04;  // 0.06 -> 0.02
            } else {
                // West to North (270Â° to 360Â°)
                const t = (normalizedRotation - Math.PI * 1.5) / (Math.PI / 2);
                r = 0.10 - t * 0.08;  // 0.10 -> 0.02
                g = 0.06 - t * 0.04;  // 0.06 -> 0.02
                b = 0.02 + t * 0.06;  // 0.02 -> 0.08
            }
            
            // Set the background color
            gl.clearColor(r, g, b, 1.0);
            
            // Clear the canvas and depth buffer
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Update rotation uniforms (still needed for shader)
            gl.uniform1f(uRotationX, rotationX);
            gl.uniform1f(uRotationY, rotationY);
            
            // Calculate current positions and update history
            const currentStarData = [];
            const trailData = [];
            
            stars.forEach(star => {
                // First apply automatic slow rotation to the original position
                const autoRotated = applyAutoRotation(star.original, time);
                
                // Then apply camera rotation to the auto-rotated position
                const rotated = rotatePoint(autoRotated, rotationX, rotationY);
                
                // Add to history
                star.history.push(rotated);
                if (star.history.length > trailLength) {
                    star.history.shift();  // Remove oldest position
                }
                
                // Calculate twinkle brightness (0.2 to 1.2 range for dramatic effect)
                const twinkle = 0.2 + smoothNoise(time * star.twinkleSpeed + star.twinkleOffset) * 1.0;
                
                // Apply twinkle to color
                const twinkledColor = star.color.map(c => c * twinkle);
                
                // Add current star data [x, y, z, r, g, b]
                currentStarData.push(...rotated, ...twinkledColor);
                
                // Create trail line segments
                for (let i = 0; i < star.history.length - 1; i++) {
                    const alpha = i / star.history.length;  // Fade older segments
                    const pos1 = star.history[i];
                    const pos2 = star.history[i + 1];
                    
                    // Add two vertices for the line segment with fading alpha
                    trailData.push(...pos1, ...star.color.map(c => c * alpha));
                    trailData.push(...pos2, ...star.color.map(c => c * alpha));
                }
            });
            
            // Draw trails first (behind the stars)
            if (trailData.length > 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, trailBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(trailData), gl.DYNAMIC_DRAW);
                
                gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
                gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
                
                // Set uniforms to identity (trails already rotated)
                gl.uniform1f(uRotationX, 0);
                gl.uniform1f(uRotationY, 0);
                
                gl.drawArrays(gl.LINES, 0, trailData.length / 6);
            }
            
            // Draw current stars
            gl.bindBuffer(gl.ARRAY_BUFFER, starBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(currentStarData), gl.DYNAMIC_DRAW);
            
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
            
            // Reset uniforms to 0 since we already rotated positions
            gl.uniform1f(uRotationX, 0);
            gl.uniform1f(uRotationY, 0);
            
            gl.drawArrays(gl.POINTS, 0, starCount);
            
            // ============================================
            // RENDER PLANETS (3D SPHERES) - After stars so they're always on top
            // ============================================
            
            if (planets.length > 0) {
                const planetData = [];
                
                // Light direction (from upper-right-front)
                const lightDir = [0.5, 0.7, 0.8];
                const lightLen = Math.sqrt(lightDir[0]**2 + lightDir[1]**2 + lightDir[2]**2);
                const lightDirNorm = [lightDir[0]/lightLen, lightDir[1]/lightLen, lightDir[2]/lightLen];
                
                planets.forEach(planet => {
                    // Apply auto-rotation to planet position
                    const autoRotated = applyAutoRotation(planet.original, time);
                    
                    // Apply camera rotation
                    const rotated = rotatePoint(autoRotated, rotationX, rotationY);
                    
                    // For each triangle face in the planet geometry
                    planetGeometry.faces.forEach(face => {
                        face.forEach(vertexIndex => {
                            const vertex = planetGeometry.vertices[vertexIndex];
                            
                            // Scale vertex by planet size
                            const scaledX = vertex[0] * planet.size;
                            const scaledY = vertex[1] * planet.size;
                            const scaledZ = vertex[2] * planet.size;
                            
                            // Translate to planet position
                            const worldX = scaledX + rotated[0];
                            const worldY = scaledY + rotated[1];
                            const worldZ = scaledZ + rotated[2];
                            
                            // Normal is just the normalized vertex position (for sphere)
                            const normal = vertex;
                            
                            // Calculate lighting (Lambert diffuse)
                            const dotProduct = normal[0] * lightDirNorm[0] + 
                                             normal[1] * lightDirNorm[1] + 
                                             normal[2] * lightDirNorm[2];
                            const lightIntensity = Math.max(dotProduct * 0.7 + 0.3, 0.1); // 0.1 to 1.0
                            
                            // Interpolate between base and highlight colors based on lighting
                            const mixFactor = Math.max((dotProduct + 1.0) / 2.0, 0.0); // 0 to 1
                            const r = planet.colorBase[0] * (1 - mixFactor) + planet.colorHighlight[0] * mixFactor;
                            const g = planet.colorBase[1] * (1 - mixFactor) + planet.colorHighlight[1] * mixFactor;
                            const b = planet.colorBase[2] * (1 - mixFactor) + planet.colorHighlight[2] * mixFactor;
                            
                            // Apply lighting intensity (fully opaque)
                            const finalR = r * lightIntensity;
                            const finalG = g * lightIntensity;
                            const finalB = b * lightIntensity;
                            
                            planetData.push(worldX, worldY, worldZ, finalR, finalG, finalB);
                        });
                    });
                });
                
                // Render planets (disable depth test so they always render on top of stars)
                if (planetData.length > 0) {
                    gl.disable(gl.DEPTH_TEST);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, planetBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(planetData), gl.DYNAMIC_DRAW);
                    
                    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
                    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
                    
                    // Already rotated, so set uniforms to identity
                    gl.uniform1f(uRotationX, 0);
                    gl.uniform1f(uRotationY, 0);
                    
                    gl.drawArrays(gl.TRIANGLES, 0, planetData.length / 6);
                    
                    // Re-enable depth test for other objects
                    gl.enable(gl.DEPTH_TEST);
                }
            }
            
            // ============================================
            // RENDER SHOOTING STARS WITH ENHANCED TRAILS
            // ============================================
            
            if (shootingStars.length > 0) {
                // Prepare shooting star data
                const shootingStarPointData = [];
                const shootingStarTrailData = [];
                
                shootingStars.forEach(star => {
                    // Calculate fade-out based on lifetime
                    const lifetimeProgress = star.lifetime / star.maxLifetime;
                    const fadeFactor = 1.0 - lifetimeProgress;  // Fade out as lifetime progresses
                    
                    // Get the most recent position (already rotated in update loop)
                    if (star.history.length > 0) {
                        const currentPos = star.history[star.history.length - 1];
                        
                        // Shooting star point (brighter than regular stars)
                        const brightness = 2.0 * fadeFactor;  // 2x brighter than regular stars
                        shootingStarPointData.push(
                            ...currentPos,
                            star.color[0] * brightness,
                            star.color[1] * brightness,
                            star.color[2] * brightness
                        );
                        
                        // Create enhanced trail with gradient fade
                        for (let i = 0; i < star.history.length - 1; i++) {
                            const trailProgress = i / star.history.length;
                            const trailAlpha = trailProgress * fadeFactor;  // Fade both by position and lifetime
                            const pos1 = star.history[i];
                            const pos2 = star.history[i + 1];
                            
                            // Brighter trail with gradient
                            const trailBrightness = trailAlpha * 1.5;
                            shootingStarTrailData.push(
                                ...pos1,
                                star.color[0] * trailBrightness,
                                star.color[1] * trailBrightness,
                                star.color[2] * trailBrightness
                            );
                            shootingStarTrailData.push(
                                ...pos2,
                                star.color[0] * trailBrightness,
                                star.color[1] * trailBrightness,
                                star.color[2] * trailBrightness
                            );
                        }
                    }
                });
                
                // Use additive blending for shooting stars (glow effect)
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                
                // Draw shooting star trails
                if (shootingStarTrailData.length > 0) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, trailBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shootingStarTrailData), gl.DYNAMIC_DRAW);
                    
                    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
                    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
                    
                    gl.uniform1f(uRotationX, 0);
                    gl.uniform1f(uRotationY, 0);
                    
                    gl.drawArrays(gl.LINES, 0, shootingStarTrailData.length / 6);
                }
                
                // Draw shooting star points
                if (shootingStarPointData.length > 0) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, starBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(shootingStarPointData), gl.DYNAMIC_DRAW);
                    
                    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
                    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
                    
                    gl.drawArrays(gl.POINTS, 0, shootingStarPointData.length / 6);
                }
                
                // Restore normal blending
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            }
            
            // ============================================
            // RENDER ENEMIES (PYRAMIDS)
            // ============================================
            
            if (enemies.length > 0) {
                const enemyData = [];
                
                enemies.forEach(enemy => {
                    // For each enemy, transform pyramid vertices
                    pyramidGeometry.faces.forEach(face => {
                        face.forEach(vertexIndex => {
                            const baseVertex = pyramidGeometry.vertices[vertexIndex];
                            
                            // Apply enemy's fixed rotation to point apex toward origin
                            // First rotate around Y axis (horizontal)
                            const cosRotY = Math.cos(enemy.rotationY);
                            const sinRotY = Math.sin(enemy.rotationY);
                            const x1 = baseVertex[0] * cosRotY - baseVertex[2] * sinRotY;
                            const z1 = baseVertex[0] * sinRotY + baseVertex[2] * cosRotY;
                            
                            // Then rotate around X axis (vertical)
                            const cosRotX = Math.cos(enemy.rotationX);
                            const sinRotX = Math.sin(enemy.rotationX);
                            const y1 = baseVertex[1] * cosRotX - z1 * sinRotX;
                            const z2 = baseVertex[1] * sinRotX + z1 * cosRotX;
                            
                            // Scale and translate to enemy position
                            const worldX = x1 * enemy.size + enemy.position[0];
                            const worldY = y1 * enemy.size + enemy.position[1];
                            const worldZ = z2 * enemy.size + enemy.position[2];
                            
                            // Apply camera rotation
                            const cameraRotated = rotatePoint([worldX, worldY, worldZ], rotationX, rotationY);
                            
                            // Add vertex position and color
                            enemyData.push(...cameraRotated, ...enemy.color);
                        });
                    });
                });
                
                if (enemyData.length > 0) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, enemyBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(enemyData), gl.DYNAMIC_DRAW);
                    
                    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 24, 0);
                    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 24, 12);
                    
                    // Already rotated, so set uniforms to identity
                    gl.uniform1f(uRotationX, 0);
                    gl.uniform1f(uRotationY, 0);
                    
                    gl.drawArrays(gl.TRIANGLES, 0, enemyData.length / 6);
                }
            }
            
            // ============================================
            // RENDER DIRECTION INDICATOR SPHERE
            // ============================================
            
            // Calculate viewing direction vector
            const viewDir = [
                Math.sin(rotationY) * Math.cos(rotationX),
                -Math.sin(rotationX),
                -Math.cos(rotationY) * Math.cos(rotationX)
            ];
            
            // Calculate brightness for all faces using smooth falloff (spotlight effect)
            // This creates a circular gradient instead of irregular polygon selection
            const faceBrightness = [];
            
            icosphere.faceNormals.forEach((normal, index) => {
                const dot = normal[0] * viewDir[0] + normal[1] * viewDir[1] + normal[2] * viewDir[2];
                
                // Smooth falloff: faces pointing toward view get brightness, others fade to 0
                // Using smoothstep for smooth circular gradient
                const minDot = 0.5;   // Start fading here
                const maxDot = 1.0;   // Full brightness here
                
                let brightness = 0;
                if (dot > minDot) {
                    // Smoothstep function for smooth interpolation
                    const t = (dot - minDot) / (maxDot - minDot);
                    brightness = t * t * (3.0 - 2.0 * t);  // Smoothstep formula
                }
                
                faceBrightness.push({ index, brightness, dot });
            });
            
            // Prepare wireframe edges for all faces
            const wireframeData = [];
            icosphere.faces.forEach((face, faceIndex) => {
                const v0 = icosphere.vertices[face[0]];
                const v1 = icosphere.vertices[face[1]];
                const v2 = icosphere.vertices[face[2]];
                
                // Scale vertices
                const sv0 = [v0[0] * 0.8, v0[1] * 0.8, v0[2] * 0.8];
                const sv1 = [v1[0] * 0.8, v1[1] * 0.8, v1[2] * 0.8];
                const sv2 = [v2[0] * 0.8, v2[1] * 0.8, v2[2] * 0.8];
                
                // White wireframe with subtle opacity
                const wireColor = [1.0, 1.0, 1.0, 0.15];
                
                // Three edges per triangle
                wireframeData.push(...sv0, ...wireColor);
                wireframeData.push(...sv1, ...wireColor);
                
                wireframeData.push(...sv1, ...wireColor);
                wireframeData.push(...sv2, ...wireColor);
                
                wireframeData.push(...sv2, ...wireColor);
                wireframeData.push(...sv0, ...wireColor);
            });
            
            // Prepare filled faces data with smooth gradient glow effect
            const gradientFacesData = [];
            faceBrightness.forEach((faceInfo) => {
                // Only render faces with brightness > 0
                if (faceInfo.brightness > 0) {
                    const face = icosphere.faces[faceInfo.index];
                    // Glow factor based on brightness (smooth circular gradient)
                    const glow = 1.2 + faceInfo.brightness * 1.3;  // Range from 1.2 to 2.5
                    
                    face.forEach(vertexIndex => {
                        const vertex = icosphere.vertices[vertexIndex];
                        gradientFacesData.push(vertex[0] * 0.8, vertex[1] * 0.8, vertex[2] * 0.8);
                        // Red/orange with brightness-based glow creating circular spotlight
                        gradientFacesData.push(glow, 0.3 * glow, 0.2 * glow, faceInfo.brightness);
                    });
                }
            });
            
            // Set up mini-viewport in bottom-right corner
            const sphereSize = 150;
            const spherePadding = 20;
            const sphereX = canvas.width - sphereSize - spherePadding;
            const sphereY = canvas.height - sphereSize - spherePadding;
            
            gl.viewport(sphereX, sphereY, sphereSize, sphereSize);
            
            // Don't clear the sphere area - let the main scene show through
            
            // Update projection for sphere (different aspect ratio)
            const sphereProjection = createPerspectiveMatrix(Math.PI / 4, 1.0, 0.1, 100.0);
            gl.uniformMatrix4fv(uProjection, false, sphereProjection);
            
            // Sphere doesn't rotate with view - it stays fixed
            gl.uniform1f(uRotationX, 0);
            gl.uniform1f(uRotationY, 0);
            
            // Enable alpha blending for transparent wireframe
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            // Isometric rotation angles
            const isoRotX = Math.atan(1 / Math.sqrt(2));  // ~35.264 degrees
            const isoRotY = Math.PI / 4;  // 45 degrees
            
            // Helper function to apply isometric rotation
            function applyIsometricRotation(x, y, z) {
                // Rotate around Y axis
                const cosY = Math.cos(isoRotY);
                const sinY = Math.sin(isoRotY);
                const x1 = x * cosY - z * sinY;
                const z1 = x * sinY + z * cosY;
                
                // Rotate around X axis
                const cosX = Math.cos(isoRotX);
                const sinX = Math.sin(isoRotX);
                const y1 = y * cosX - z1 * sinX;
                const z2 = y * sinX + z1 * cosX;
                
                return [x1, y1, z2];
            }
            
            // Draw wireframe edges (apply isometric rotation and push back in Z)
            const transformedWireframeData = [];
            for (let i = 0; i < wireframeData.length; i += 7) {
                const [rx, ry, rz] = applyIsometricRotation(wireframeData[i], wireframeData[i + 1], wireframeData[i + 2]);
                transformedWireframeData.push(rx, ry, rz - 2.5);
                transformedWireframeData.push(wireframeData[i + 3], wireframeData[i + 4], wireframeData[i + 5], wireframeData[i + 6]);
            }
            
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(transformedWireframeData), gl.DYNAMIC_DRAW);
            
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 28, 0);
            gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 28, 12);
            
            gl.drawArrays(gl.LINES, 0, transformedWireframeData.length / 7);
            
            // Draw filled faces with smooth gradient glow (apply isometric rotation and push back in Z)
            if (gradientFacesData.length > 0) {
                // Use additive blending for glow effect
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                
                const transformedGradientFacesData = [];
                for (let i = 0; i < gradientFacesData.length; i += 7) {
                    const [rx, ry, rz] = applyIsometricRotation(gradientFacesData[i], gradientFacesData[i + 1], gradientFacesData[i + 2]);
                    transformedGradientFacesData.push(rx, ry, rz - 2.5);
                    transformedGradientFacesData.push(gradientFacesData[i + 3], gradientFacesData[i + 4], gradientFacesData[i + 5], gradientFacesData[i + 6]);
                }
                
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(transformedGradientFacesData), gl.DYNAMIC_DRAW);
                
                gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 28, 0);
                gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 28, 12);
                
                gl.drawArrays(gl.TRIANGLES, 0, transformedGradientFacesData.length / 7);
            }
            
            // Restore main viewport
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.uniformMatrix4fv(uProjection, false, projectionMatrix);
            
            // ============================================
            // UPDATE DISTANCE DISPLAY
            // ============================================
            
            const targetInfo = findClosestObjectToCenter();
            if (targetInfo) {
                // Format distance with 2 decimal places
                const distanceText = targetInfo.distance.toFixed(2) + ' units';
                distanceDisplay.textContent = distanceText;
                
                // Optional: Change color based on object type
                if (targetInfo.object.type === 'enemy') {
                    distanceDisplay.style.color = '#ff4444';  // Red for enemies
                } else if (targetInfo.object.type === 'planet') {
                    distanceDisplay.style.color = '#44aaff';  // Blue for planets
                } else {
                    distanceDisplay.style.color = '#00ff00';  // Green for stars
                }
            } else {
                // No object targeted
                distanceDisplay.textContent = '--';
                distanceDisplay.style.color = '#00ff00';
            }
            
            requestAnimationFrame(render);
        }
        
        // Start the animation
        render();
        console.log('âœ“ Rendering started with position history trails!');
        
        // ============================================
        // 10. HANDLE WINDOW RESIZE
        // ============================================
        
        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            // Update projection matrix with new aspect ratio
            const aspect = canvas.width / canvas.height;
            const newProjectionMatrix = createPerspectiveMatrix(Math.PI / 4, aspect, 0.1, 100.0);
            gl.uniformMatrix4fv(uProjection, false, newProjectionMatrix);
        });
        
    </script>
</body>
</html>
